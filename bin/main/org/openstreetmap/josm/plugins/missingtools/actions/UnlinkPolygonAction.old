package org.openstreetmap.josm.plugins.missingtools.actions;

import static org.openstreetmap.josm.tools.I18n.marktr;
import static org.openstreetmap.josm.tools.I18n.tr;
import static org.openstreetmap.josm.tools.I18n.trn;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Arrays;

import javax.swing.JOptionPane;

import org.openstreetmap.josm.actions.mapmode.MapMode;
import org.openstreetmap.josm.actions.mapmode.ParallelWays;
import org.openstreetmap.josm.command.AddCommand;
import org.openstreetmap.josm.command.ChangeCommand;
import org.openstreetmap.josm.command.ChangeNodesCommand;
import org.openstreetmap.josm.command.Command;
import org.openstreetmap.josm.command.DeleteCommand;
import org.openstreetmap.josm.command.SequenceCommand;
import org.openstreetmap.josm.command.SplitWayCommand;
import org.openstreetmap.josm.data.Bounds;
import org.openstreetmap.josm.data.SystemOfMeasurement;
import org.openstreetmap.josm.data.UndoRedoHandler;
import org.openstreetmap.josm.data.coor.EastNorth;
import org.openstreetmap.josm.data.coor.ILatLon;
import org.openstreetmap.josm.data.osm.DataSet;
import org.openstreetmap.josm.data.osm.DefaultNameFormatter;
import org.openstreetmap.josm.data.osm.MultipolygonBuilder;
import org.openstreetmap.josm.data.osm.MultipolygonBuilder.JoinedPolygon;
import org.openstreetmap.josm.data.osm.Node;
import org.openstreetmap.josm.data.osm.OsmPrimitive;
import org.openstreetmap.josm.data.osm.OsmPrimitiveType;
import org.openstreetmap.josm.data.osm.Relation;
import org.openstreetmap.josm.data.osm.RelationMember;
import org.openstreetmap.josm.data.osm.Way;
import org.openstreetmap.josm.data.osm.WaySegment;
import org.openstreetmap.josm.data.preferences.AbstractToStringProperty;
import org.openstreetmap.josm.data.preferences.BooleanProperty;
import org.openstreetmap.josm.data.preferences.CachingProperty;
import org.openstreetmap.josm.data.preferences.DoubleProperty;
import org.openstreetmap.josm.data.preferences.IntegerProperty;
import org.openstreetmap.josm.data.preferences.NamedColorProperty;
import org.openstreetmap.josm.data.preferences.StrokeProperty;
import org.openstreetmap.josm.gui.MainApplication;
import org.openstreetmap.josm.gui.MapFrame;
import org.openstreetmap.josm.gui.MapView;
import org.openstreetmap.josm.gui.Notification;
import org.openstreetmap.josm.gui.draw.MapViewPath;
import org.openstreetmap.josm.gui.layer.AbstractMapViewPaintable;
import org.openstreetmap.josm.gui.layer.Layer;
import org.openstreetmap.josm.gui.util.ModifierExListener;
import org.openstreetmap.josm.plugins.missingtools.utils.NodeWayUtils;
import org.openstreetmap.josm.plugins.missingtools.utils.OsmEdge;
import org.openstreetmap.josm.plugins.missingtools.utils.RoutingGraph;

import org.openstreetmap.josm.plugins.utilsplugin2.actions.SplitObjectAction;
import org.openstreetmap.josm.tools.CheckParameterUtil;
import org.openstreetmap.josm.tools.Geometry;
import org.openstreetmap.josm.tools.ImageProvider;
import org.openstreetmap.josm.tools.Logging;
import org.openstreetmap.josm.tools.Pair;
import org.openstreetmap.josm.tools.Shortcut;

/**
 * MapMode for making parallel ways.
 * <p>
 * All calculations are done in projected coordinates.
 * <p>
 * TODO:
 * <p>
 * == Functionality ==
 * <ol>
 * <li>Use selected nodes as split points for the selected ways.
 * <p>
 * The ways containing the selected nodes will be split and only the "inner"
 * parts will be copied</li>
 * <li>Enter exact offset</li>
 * <li>Improve snapping</li>
 * <li>Visual cues could be better</li>
 * <li>(long term) Parallelize and adjust offsets of existing ways</li>
 * </ol>
 * == Code quality ==
 * <ol type="a">
 * <li>The mode, flags, and modifiers might be updated more than necessary.
 * <p>
 * Not a performance problem, but better if they where more centralized</li>
 * <li>Extract generic MapMode services into a super class and/or utility
 * class</li>
 * <li>Maybe better to simply draw our own source way highlighting?</li>
 * </ol>
 * Current code doesn't not take into account that ways might been highlighted
 * by other than us. Don't think that situation should ever happen though.
 *
 * @author Ole Jørgen Brønner (olejorgenb)
 */
public class UnlinkPolygonAction extends MapMode implements ModifierExListener {

    private static final CachingProperty<BasicStroke> HELPER_LINE_STROKE = new StrokeProperty(
            prefKey("stroke.hepler-line"), "1").cached();
    private static final CachingProperty<BasicStroke> REF_LINE_STROKE = new StrokeProperty(prefKey("stroke.ref-line"),
            "2 2 3").cached();

    // @formatter:off
    // CHECKSTYLE.OFF: SingleSpaceSeparator
    private static final CachingProperty<Double> SNAP_THRESHOLD         = new DoubleProperty(prefKey("snap-threshold-percent"), 0.70).cached();
    private static final CachingProperty<Boolean> SNAP_DEFAULT          = new BooleanProperty(prefKey("snap-default"),      true).cached();
    private static final CachingProperty<Boolean> COPY_TAGS_DEFAULT     = new BooleanProperty(prefKey("copy-tags-default"), false).cached();
    private static final CachingProperty<Integer> INITIAL_MOVE_DELAY    = new IntegerProperty(prefKey("initial-move-delay"), 200).cached();
    private static final CachingProperty<Double> SNAP_DISTANCE_METRIC   = new DoubleProperty(prefKey("snap-distance-metric"), 0.5).cached();
    private static final CachingProperty<Double> SNAP_DISTANCE_IMPERIAL = new DoubleProperty(prefKey("snap-distance-imperial"), 1).cached();
    private static final CachingProperty<Double> SNAP_DISTANCE_CHINESE  = new DoubleProperty(prefKey("snap-distance-chinese"), 1).cached();
    private static final CachingProperty<Double> SNAP_DISTANCE_NAUTICAL = new DoubleProperty(prefKey("snap-distance-nautical"), 0.1).cached();
    private static final CachingProperty<Color> MAIN_COLOR = new NamedColorProperty(marktr("make parallel helper line"), Color.RED).cached();

    private static final CachingProperty<Map<Modifier, Boolean>> SNAP_MODIFIER_COMBO
            = new KeyboardModifiersProperty(prefKey("snap-modifier-combo"),             "?Sc").cached();
    private static final CachingProperty<Map<Modifier, Boolean>> COPY_TAGS_MODIFIER_COMBO
            = new KeyboardModifiersProperty(prefKey("copy-tags-modifier-combo"),        "As?").cached();
    private static final CachingProperty<Map<Modifier, Boolean>> ADD_TO_SELECTION_MODIFIER_COMBO
            = new KeyboardModifiersProperty(prefKey("add-to-selection-modifier-combo"), "aSc").cached();
    private static final CachingProperty<Map<Modifier, Boolean>> TOGGLE_SELECTED_MODIFIER_COMBO
            = new KeyboardModifiersProperty(prefKey("toggle-selection-modifier-combo"), "asC").cached();
    private static final CachingProperty<Map<Modifier, Boolean>> SET_SELECTED_MODIFIER_COMBO
            = new KeyboardModifiersProperty(prefKey("set-selection-modifier-combo"),    "asc").cached();
    // CHECKSTYLE.ON: SingleSpaceSeparator
    // @formatter:on

    enum Mode {
        DRAGGING, NORMAL
    }

    //// Preferences and flags
    // See updateModeLocalPreferences for defaults
    private Mode mode;
    private boolean copyTags;

    private boolean snap;

    private final MapView mv;

    // Mouse tracking state
    private Point mousePressedPos;
    private boolean mouseIsDown;
    private long mousePressedTime;
    private boolean mouseHasBeenDragged;

    private transient WaySegment referenceSegment;
    private transient ParallelWays pWays;
    // private transient ParallelWays pWaysMirrored;
    private transient Set<Way> sourceWays;
    private EastNorth helperLineStart;
    private EastNorth helperLineEnd;

    private final ParallelWayLayer temporaryLayer = new ParallelWayLayer();

    // Custom
    private DataSet ds;
    private transient Node selectedNode;
    private transient Set<Node> selectedNodes;
    List<Node> allNewNodes;
    List<Way> affectedWays;
    // List<Node> commonNodes;

    Set<Relation> newRelations;
    long cutPathId;

    /**
     * Constructs a new {@code PolygonCutAction}.
     * 
     * @param mapFrame Map frame
     */
    public UnlinkPolygonAction(MapFrame mapFrame) {
        super(tr("Polygon Unlink"),
                "polyunlink",
                tr("Cut Polygon by parallel copies of ways"),
                Shortcut.registerShortcut("mapmode:unlinkmultipolygon",
                        tr("Mode: {0}", tr("Polygon Unlink")),
                        KeyEvent.VK_X, Shortcut.SHIFT),
                ImageProvider.getCursor("normal", "parallel"));
        // setHelpId(ht("/Action/Parallel"));
        mv = mapFrame.mapView;
    }

    @Override
    public void enterMode() {
        // super.enterMode() updates the status line and cursor so we need our state to
        // be set correctly
        setMode(Mode.NORMAL);
        pWays = null;
        // pWaysMirrored = null;
        super.enterMode();

        // #19887: overwrite default: we want to show the distance to the original way
        MainApplication.getMap().statusLine.setAutoLength(false);

        mv.addMouseListener(this);
        mv.addMouseMotionListener(this);
        mv.addTemporaryLayer(temporaryLayer);

        // Needed to update the mouse cursor if modifiers are changed when the mouse is
        // motionless
        MainApplication.getMap().keyDetector.addModifierExListener(this);
        sourceWays = new LinkedHashSet<>(getLayerManager().getEditDataSet().getSelectedWays());
        for (Way w : sourceWays) {
            w.setHighlighted(true);
        }

        performUnlinkNodes();
    }

    private void performUnlinkNodes() {

        ds = getLayerManager().getActiveDataSet();
        Collection<Way> selectedWays = ds.getSelectedWays();

        if (!isEnabled()) {
            return;
        }

        if (!selectedWays.isEmpty() && selectedWays.size() == 1) {
            // Selected
            Iterator<Way> iterator = selectedWays.iterator();
            Way selectedWay = iterator.next();

            if (!selectedWay.isClosed()) {
                return;
            }

            // Id to select way later as source for Offset
            cutPathId = selectedWay.getUniqueId();

            List<Node> selectedWayNodes = selectedWay.getNodes();
            List<Node> processedNodes = new ArrayList<>();
            allNewNodes = new ArrayList<>();
            affectedWays = new ArrayList<>();

            selectedWayNodes.forEach(selectedWayNode -> {

                // Check if node was already processed
                if (!processedNodes.contains(selectedWayNode)) {

                    List<Way> parentWaysOfNode = selectedWayNode.getParentWays();

                    if (parentWaysOfNode.size() > 1) {

                        List<Node> commonNodes = new ArrayList<>();

                        for (Way parentWayOfNodeToUnglueFrom : parentWaysOfNode) {
                            // Process glued ways that are unclosed Ways
                            // Additional check for multipolygon

                            boolean partOfMultipolygon = false;
                            Set<Relation> parentRelations = OsmPrimitive
                                    .getParentRelations(Collections.singleton(parentWayOfNodeToUnglueFrom));
                            for (Relation relation : parentRelations) {
                                // check if complete and check if Relation is fully crossed
                                if ("multipolygon".equals(relation.get("type"))) {
                                    partOfMultipolygon = true;
                                }
                            }

                            // check if node is attached to unclosed way (for example highway=)
                            // TODO: add logic for Multipolygons
                            if (parentWayOfNodeToUnglueFrom.getUniqueId() != selectedWay.getUniqueId()
                                    && !parentWayOfNodeToUnglueFrom.isClosed() && !partOfMultipolygon) {

                                List<Node> nodesOfWayOfNodeToUnglueFrom = parentWayOfNodeToUnglueFrom.getNodes();

                                for (Node selectedWayNodeToUnglue : selectedWayNodes) {

                                    if (nodesOfWayOfNodeToUnglueFrom.contains(selectedWayNodeToUnglue)
                                            && !processedNodes.contains(selectedWayNodeToUnglue)) {
                                        if (!commonNodes.contains(selectedWayNodeToUnglue)) {
                                            commonNodes.add(selectedWayNodeToUnglue);
                                        }
                                    }
                                }

                                break;
                            }
                            // check for other areas
                            else if (parentWayOfNodeToUnglueFrom.getUniqueId() != selectedWay.getUniqueId()
                                    && parentWayOfNodeToUnglueFrom.isClosed() && !partOfMultipolygon) {
                                affectedWays.add(parentWayOfNodeToUnglueFrom);
                            }
                        }

                        if (commonNodes.size() > 0) {

                            processedNodes.addAll(commonNodes);

                            List<Command> cmds = new ArrayList<>();

                            Map<Node, Node> duplicateReplacementNodesForCommonNodes = new HashMap<>();
                            commonNodes.forEach(
                                    node -> duplicateReplacementNodesForCommonNodes.put(node, cloneNode(node, cmds)));

                            List<Node> nodesOfSelectedWay = new ArrayList<>(selectedWay.getNodes());
                            nodesOfSelectedWay.replaceAll(
                                    node -> duplicateReplacementNodesForCommonNodes.getOrDefault(node, node));

                            selectedNodes = new HashSet<>(commonNodes);

                            // only one changeCommand for a way, else garbage will happen
                            addCheckedChangeNodesCmd(cmds, selectedWay, nodesOfSelectedWay);
                            UndoRedoHandler.getInstance().add(new SequenceCommand(
                                    trn("Dupe {0} node into {1} nodes", "Dupe {0} nodes into {1} nodes",
                                            commonNodes.size(), commonNodes.size(), 2 * commonNodes.size()),
                                    cmds));

                            Collection<Node> newUngluedNodes = duplicateReplacementNodesForCommonNodes.values();

                            // EastNorth centerCoordinates = Geometry.getCentroid(selectedWayNodes);

                            for (Node newNode : newUngluedNodes) {
                                // moveNodeInDirection(newNode, centerCoordinates, 0.01);
                                allNewNodes.add(newNode);
                            }
                        }
                    }
                }
            });

            if (allNewNodes.size() > 0) {
                getLayerManager().getEditDataSet().setSelected(allNewNodes);
            }

        }

    }

    private static Node cloneNode(Node originalNode, List<Command> cmds) {
        Node newNode = new Node(originalNode, true /* clear OSM ID */);
        cmds.add(new AddCommand(originalNode.getDataSet(), newNode));
        return newNode;
    }

    private boolean addCheckedChangeNodesCmd(List<Command> cmds, Way w, List<Node> nodes) {
        boolean relationCheck = !calcAffectedRelations(Collections.singleton(w)).isEmpty();
        cmds.add(new ChangeNodesCommand(w, nodes));
        if (relationCheck) {
            notifyWayPartOfRelation(Collections.singleton(w));
        }
        return relationCheck;
    }

    protected Set<Relation> calcAffectedRelations(final Collection<Way> ways) {
        final Set<Node> affectedNodes = (selectedNodes != null) ? selectedNodes : Collections.singleton(selectedNode);
        return OsmPrimitive.getParentRelations(ways)
                .stream().filter(r -> isRelationAffected(r, affectedNodes, ways))
                .collect(Collectors.toSet());
    }

    protected void notifyWayPartOfRelation(final Collection<Way> ways) {
        Set<Relation> affectedRelations = calcAffectedRelations(ways);
        if (affectedRelations.isEmpty()) {
            return;
        }
        final int size = affectedRelations.size();
        final String msg1 = trn("Unglueing possibly affected {0} relation: {1}",
                "Unglueing possibly affected {0} relations: {1}",
                size, size, DefaultNameFormatter.getInstance().formatAsHtmlUnorderedList(affectedRelations, 20));
        final String msg2 = trn("Ensure that the relation has not been broken!",
                "Ensure that the relations have not been broken!",
                size);
        new Notification(msg1 + msg2).setIcon(JOptionPane.WARNING_MESSAGE).show();
    }

    private static boolean isRelationAffected(Relation r, Set<Node> affectedNodes, Collection<Way> ways) {
        if (!r.isUsable())
            return false;
        // see #18670: suppress notification when well known restriction types are not
        // affected
        if (!r.hasTag("type", "restriction", "connectivity", "destination_sign") || r.hasIncompleteMembers())
            return true;
        int count = 0;
        for (RelationMember rm : r.getMembers()) {
            if (rm.isNode() && affectedNodes.contains(rm.getNode()))
                count++;
            if (rm.isWay() && ways.contains(rm.getWay())) {
                count++;
                if ("via".equals(rm.getRole())) {
                    count++;
                }
            }
        }
        return count >= 2;
    }

    @Override
    public void exitMode() {
        super.exitMode();
        mv.removeMouseListener(this);
        mv.removeMouseMotionListener(this);
        mv.removeTemporaryLayer(temporaryLayer);
        MapFrame map = MainApplication.getMap();
        map.statusLine.setDist(-1);
        map.keyDetector.removeModifierExListener(this);
        removeWayHighlighting(sourceWays);
        pWays = null;
        // pWaysMirrored = null;
        sourceWays = null;
        referenceSegment = null;
    }

    @Override
    public String getModeHelpText() {
        // TODO: add more detailed feedback based on modifier state.
        // TODO: dynamic messages based on preferences. (Could be problematic
        // translation wise)
        switch (mode) {
            case NORMAL:
                // CHECKSTYLE.OFF: LineLength
                return tr(
                        "Select ways as in Select mode. Drag selected ways or a single way to create a parallel copy (Alt toggles tag preservation)");
            // CHECKSTYLE.ON: LineLength
            case DRAGGING:
                return tr("Hold Ctrl to toggle snapping");
        }
        return ""; // impossible ..
    }

    @Override
    public boolean layerIsSupported(Layer l) {
        return isEditableDataLayer(l);
    }

    @Override
    public void modifiersExChanged(int modifiers) {
        if (MainApplication.getMap() == null || mv == null || !mv.isActiveLayerDrawable())
            return;

        // Should only get InputEvents due to the mask in enterMode
        if (updateModifiersState(modifiers)) {
            updateStatusLine();
            updateCursor();
        }
    }

    private boolean updateModifiersState(int modifiers) {
        boolean oldAlt = alt, oldShift = shift, oldCtrl = ctrl;
        updateKeyModifiersEx(modifiers);
        return oldAlt != alt || oldShift != shift || oldCtrl != ctrl;
    }

    private void updateCursor() {
        Cursor newCursor = null;
        switch (mode) {
            case NORMAL:
                if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {
                    newCursor = ImageProvider.getCursor("normal", "parallel");
                } else if (matchesCurrentModifiers(ADD_TO_SELECTION_MODIFIER_COMBO)) {
                    newCursor = ImageProvider.getCursor("normal", "parallel_add");
                } else if (matchesCurrentModifiers(TOGGLE_SELECTED_MODIFIER_COMBO)) {
                    newCursor = ImageProvider.getCursor("normal", "parallel_remove");
                }
                break;
            case DRAGGING:
                newCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
                break;
            default:
                throw new AssertionError();
        }
        if (newCursor != null) {
            mv.setNewCursor(newCursor, this);
        }
    }

    private void setMode(Mode mode) {
        this.mode = mode;
        updateCursor();
        updateStatusLine();
    }

    private boolean sanityCheck() {
        // @formatter:off
        boolean areWeSane =
            mv.isActiveLayerVisible() &&
            mv.isActiveLayerDrawable() &&
            ((Boolean) this.getValue("active"));
        // @formatter:on
        assert areWeSane; // mad == bad
        return areWeSane;
    }

    @Override
    public void mousePressed(MouseEvent e) {
        requestFocusInMapView();
        updateModifiersState(e.getModifiersEx());
        // Other buttons are off limit, but we still get events.
        if (e.getButton() != MouseEvent.BUTTON1)
            return;

        if (!sanityCheck())
            return;

        updateFlagsOnlyChangeableOnPress();
        updateFlagsChangeableAlways();

        // createCutPath();

        // Since the created way is left selected, we need to unselect again here
        if (pWays != null && pWays.getWays() != null) {
            getLayerManager().getEditDataSet().clearSelection(pWays.getWays());
            pWays = null;
        }

        // if (pWaysMirrored != null && pWaysMirrored.getWays() != null) {
        // getLayerManager().getEditDataSet().clearSelection(pWaysMirrored.getWays());
        // pWaysMirrored = null;
        // }

        mouseIsDown = true;
        mousePressedPos = e.getPoint();
        mousePressedTime = System.currentTimeMillis();

    }

    @Override
    public void mouseReleased(MouseEvent e) {
        updateModifiersState(e.getModifiersEx());
        // Other buttons are off limit, but we still get events.
        if (e.getButton() != MouseEvent.BUTTON1)
            return;

        if (!mouseHasBeenDragged) {
            // use point from press or click event? (or are these always the same)
            Way nearestWay = mv.getNearestWay(e.getPoint(), OsmPrimitive::isSelectable);
            if (nearestWay == null) {
                if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {
                    clearSourceWays();
                }
                resetMouseTrackingState();
                return;
            }
            boolean isSelected = nearestWay.isSelected();
            if (matchesCurrentModifiers(ADD_TO_SELECTION_MODIFIER_COMBO)) {
                if (!isSelected) {
                    addSourceWay(nearestWay);
                }
            } else if (matchesCurrentModifiers(TOGGLE_SELECTED_MODIFIER_COMBO)) {
                if (isSelected) {
                    removeSourceWay(nearestWay);
                } else {
                    addSourceWay(nearestWay);
                }
            } else if (matchesCurrentModifiers(SET_SELECTED_MODIFIER_COMBO)) {
                clearSourceWays();
                addSourceWay(nearestWay);
            } // else -> invalid modifier combination
        } else if (mode == Mode.DRAGGING) {
            // clearSourceWays();
            MainApplication.getMap().statusLine.setDist(pWays.getWays());
        }

        // TODO : add action

        performOffset();

        setMode(Mode.NORMAL);
        resetMouseTrackingState();
        temporaryLayer.invalidate();
    }

    private void performOffset() {

        Way sourceWay = null;

        OsmPrimitive primitive = ds.getPrimitiveById(cutPathId, OsmPrimitiveType.WAY);
        if (primitive instanceof Way) {
            sourceWay = (Way) primitive;
        }

        if (sourceWay == null || allNewNodes.size() == 0) {
            return;
        }

        List<Way> offsetWays = pWays.getWays();
        Way clonedOffsetWay = offsetWays.iterator().next();

        List<Node> way1Nodes = sourceWay.getNodes();
        List<Node> way2Nodes = clonedOffsetWay.getNodes();

        List<Node> allNewNodes2 = new ArrayList<>();

        allNewNodes.forEach(node -> {
            int index = way1Nodes.indexOf(node);
            if (index != -1) {
                way1Nodes.set(index, way2Nodes.get(index));
                allNewNodes2.add(way2Nodes.get(index));
            }
        });

        // sourceWay.setNodes(way1Nodes);
        List<Command> replaceNodesCommands = new ArrayList<>();
        replaceNodesCommands.add(new ChangeNodesCommand(sourceWay, way1Nodes));
        UndoRedoHandler.getInstance().add(new SequenceCommand(
                tr("Replace Nodes in Original way"),
                replaceNodesCommands));

        ds.setSelected(allNewNodes2);

        // Delete unnecessary Primitives
        Collection<OsmPrimitive> primitivesToDelete = new ArrayList<>();
        primitivesToDelete.add(clonedOffsetWay);
        primitivesToDelete.addAll(allNewNodes);

        Command cmd = DeleteCommand.delete(primitivesToDelete, true,
                false);
        UndoRedoHandler.getInstance().add(cmd);

        // Switch mode to SelectAction
        MapFrame map = MainApplication.getMap();
        map.selectMapMode(map.mapModeSelect);

    }

    private static void removeWayHighlighting(Collection<Way> ways) {
        if (ways == null)
            return;
        for (Way w : ways) {
            w.setHighlighted(false);
        }
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        // WTF... the event passed here doesn't have button info?
        // Since we get this event from other buttons too, we must check that
        // _BUTTON1_ is down.
        if (!mouseIsDown)
            return;

        boolean modifiersChanged = updateModifiersState(e.getModifiersEx());
        updateFlagsChangeableAlways();

        if (modifiersChanged) {
            // Since this could be remotely slow, do it conditionally
            updateStatusLine();
            updateCursor();
        }

        if ((System.currentTimeMillis() - mousePressedTime) < INITIAL_MOVE_DELAY.get())
            return;
        // Assuming this event only is emitted when the mouse has moved
        // Setting this after the check above means we tolerate clicks with some
        // movement
        mouseHasBeenDragged = true;

        if (mode == Mode.NORMAL) {
            // Should we ensure that the copyTags modifiers are still valid?

            // Important to use mouse position from the press, since the drag
            // event can come quite late
            if (!isModifiersValidForDragMode())
                return;
            if (!initParallelWays(mousePressedPos, copyTags))
                return;
            setMode(Mode.DRAGGING);
        }

        // Calculate distance to the reference line
        Point p = e.getPoint();
        EastNorth enp = mv.getEastNorth((int) p.getX(), (int) p.getY());
        EastNorth nearestPointOnRefLine = Geometry.closestPointToLine(referenceSegment.getFirstNode().getEastNorth(),
                referenceSegment.getSecondNode().getEastNorth(), enp);

        // Note: d is the distance in _projected units_
        double d = enp.distance(nearestPointOnRefLine);
        double realD = mv.getProjection().eastNorth2latlon(enp).greatCircleDistance(
                (ILatLon) mv.getProjection().eastNorth2latlon(nearestPointOnRefLine));
        double snappedRealD = realD;

        boolean toTheRight = Geometry.angleIsClockwise(
                referenceSegment.getFirstNode(), referenceSegment.getSecondNode(), new Node(enp));

        if (snap) {
            // TODO: Very simple snapping
            // - Snap steps relative to the distance?
            double snapDistance;
            SystemOfMeasurement som = SystemOfMeasurement.getSystemOfMeasurement();
            if (som.equals(SystemOfMeasurement.CHINESE)) {
                snapDistance = SNAP_DISTANCE_CHINESE.get() * SystemOfMeasurement.CHINESE.aValue;
            } else if (som.equals(SystemOfMeasurement.IMPERIAL)) {
                snapDistance = SNAP_DISTANCE_IMPERIAL.get() * SystemOfMeasurement.IMPERIAL.aValue;
            } else if (som.equals(SystemOfMeasurement.NAUTICAL_MILE)) {
                snapDistance = SNAP_DISTANCE_NAUTICAL.get() * SystemOfMeasurement.NAUTICAL_MILE.aValue;
            } else {
                snapDistance = SNAP_DISTANCE_METRIC.get(); // Metric system by default
            }
            double closestWholeUnit;
            double modulo = realD % snapDistance;
            if (modulo < snapDistance / 2.0) {
                closestWholeUnit = realD - modulo;
            } else {
                closestWholeUnit = realD + (snapDistance - modulo);
            }
            if (Math.abs(closestWholeUnit - realD) < (SNAP_THRESHOLD.get() * snapDistance)) {
                snappedRealD = closestWholeUnit;
            } else {
                snappedRealD = closestWholeUnit + Math.signum(realD - closestWholeUnit) * snapDistance;
            }
        }
        d = snappedRealD * (d / realD); // convert back to projected distance. (probably ok on small scales)
        helperLineStart = nearestPointOnRefLine;
        helperLineEnd = enp;
        if (toTheRight) {
            d = -d;
        }

        pWays.changeOffset(d);

        // pWaysMirrored.changeOffset(-d);

        MapFrame map = MainApplication.getMap();
        map.statusLine.setDist(Math.abs(snappedRealD));
        map.statusLine.repaint();
        temporaryLayer.invalidate();
    }

    private boolean matchesCurrentModifiers(CachingProperty<Map<Modifier, Boolean>> spec) {
        return matchesCurrentModifiers(spec.get());
    }

    private boolean matchesCurrentModifiers(Map<Modifier, Boolean> spec) {
        EnumSet<Modifier> modifiers = EnumSet.noneOf(Modifier.class);
        if (ctrl) {
            modifiers.add(Modifier.CTRL);
        }
        if (alt) {
            modifiers.add(Modifier.ALT);
        }
        if (shift) {
            modifiers.add(Modifier.SHIFT);
        }
        return spec.entrySet().stream().allMatch(entry -> modifiers.contains(entry.getKey()) == entry.getValue());
    }

    private boolean isModifiersValidForDragMode() {
        return (!alt && !shift && !ctrl) || matchesCurrentModifiers(SNAP_MODIFIER_COMBO)
                || matchesCurrentModifiers(COPY_TAGS_MODIFIER_COMBO);
    }

    private void updateFlagsOnlyChangeableOnPress() {
        copyTags = COPY_TAGS_DEFAULT.get() != matchesCurrentModifiers(COPY_TAGS_MODIFIER_COMBO);
    }

    private void updateFlagsChangeableAlways() {
        snap = SNAP_DEFAULT.get() != matchesCurrentModifiers(SNAP_MODIFIER_COMBO);
    }

    // We keep the source ways and the selection in sync so the user can see the
    // source way's tags
    private void addSourceWay(Way w) {
        assert sourceWays != null;
        getLayerManager().getEditDataSet().addSelected(w);
        w.setHighlighted(true);
        sourceWays.add(w);
    }

    private void removeSourceWay(Way w) {
        assert sourceWays != null;
        getLayerManager().getEditDataSet().clearSelection(w);
        w.setHighlighted(false);
        sourceWays.remove(w);
    }

    private void clearSourceWays() {
        assert sourceWays != null;
        getLayerManager().getEditDataSet().clearSelection(sourceWays);
        for (Way w : sourceWays) {
            w.setHighlighted(false);
        }
        sourceWays.clear();
    }

    private void resetMouseTrackingState() {
        mouseIsDown = false;
        mousePressedPos = null;
        mouseHasBeenDragged = false;
    }

    // TODO: rename
    private boolean initParallelWays(Point p, boolean copyTags) {

        if (cutPathId == 0) {
            return false;
        }
        Predicate<OsmPrimitive> idPredicate = primitive -> primitive.getUniqueId() == cutPathId;

        referenceSegment = mv.getNearestWaySegment(p, idPredicate, true);
        if (referenceSegment == null)
            return false;

        sourceWays.removeIf(w -> w.isIncomplete() || w.isEmpty());

        if (!sourceWays.contains(referenceSegment.getWay())) {
            clearSourceWays();
            addSourceWay(referenceSegment.getWay());
        }

        try {
            int referenceWayIndex = -1;
            int i = 0;
            for (Way w : sourceWays) {
                if (w == referenceSegment.getWay()) {
                    referenceWayIndex = i;
                    break;
                }
                i++;
            }
            pWays = new ParallelWays(sourceWays, copyTags, referenceWayIndex);
            pWays.commit();
            // pWaysMirrored = new ParallelWays(sourceWays, copyTags, referenceWayIndex);
            // pWaysMirrored.commit();

            List<Way> offsetWays = pWays.getWays();
            // offsetWays.addAll(pWaysMirrored.getWays());

            getLayerManager().getEditDataSet().setSelected(offsetWays);
            return true;
        } catch (IllegalArgumentException e) {
            Logging.debug(e);
            new Notification(tr("PolygonCutAction\n" +
                    "The ways selected must form a simple branchless path"))
                    .setIcon(JOptionPane.INFORMATION_MESSAGE)
                    .show();
            // The error dialog prevents us from getting the mouseReleased event
            resetMouseTrackingState();
            pWays = null;
            // pWaysMirrored = null;
            return false;
        }
    }

    private static String prefKey(String subKey) {
        return "edit.make-parallel-way-action." + subKey;
    }

    /**
     * A property that holds the keyboard modifiers.
     * 
     * @author Michael Zangl
     * @since 10869
     */
    private static class KeyboardModifiersProperty extends AbstractToStringProperty<Map<Modifier, Boolean>> {

        KeyboardModifiersProperty(String key, String defaultValue) {
            this(key, createFromString(defaultValue));
        }

        KeyboardModifiersProperty(String key, Map<Modifier, Boolean> defaultValue) {
            super(key, defaultValue);
        }

        @Override
        protected String toString(Map<Modifier, Boolean> t) {
            StringBuilder sb = new StringBuilder();
            for (Modifier mod : Modifier.values()) {
                Boolean val = t.get(mod);
                if (val == null) {
                    sb.append('?');
                } else if (val) {
                    sb.append(Character.toUpperCase(mod.shortChar));
                } else {
                    sb.append(mod.shortChar);
                }
            }
            return sb.toString();
        }

        @Override
        protected Map<Modifier, Boolean> fromString(String string) {
            return createFromString(string);
        }

        private static Map<Modifier, Boolean> createFromString(String string) {
            Map<Modifier, Boolean> ret = new EnumMap<>(Modifier.class);
            for (int i = 0; i < string.length(); i++) {
                char c = string.charAt(i);
                if (c == '?') {
                    continue;
                }
                Optional<Modifier> mod = Modifier.findWithShortCode(c);
                if (mod.isPresent()) {
                    ret.put(mod.get(), Character.isUpperCase(c));
                } else {
                    Logging.debug("Ignoring unknown modifier {0}", c);
                }
            }
            return Collections.unmodifiableMap(ret);
        }
    }

    enum Modifier {
        CTRL('c'),
        ALT('a'),
        SHIFT('s');

        private final char shortChar;

        Modifier(char shortChar) {
            this.shortChar = Character.toLowerCase(shortChar);
        }

        /**
         * Find the modifier with the given short code
         * 
         * @param charCode The short code
         * @return The modifier
         */
        public static Optional<Modifier> findWithShortCode(int charCode) {
            return Stream.of(values()).filter(m -> m.shortChar == Character.toLowerCase(charCode)).findAny();
        }
    }

    private class ParallelWayLayer extends AbstractMapViewPaintable {
        @Override
        public void paint(Graphics2D g, MapView mv, Bounds bbox) {
            if (mode == Mode.DRAGGING) {
                CheckParameterUtil.ensureParameterNotNull(mv, "mv");

                Color mainColor = MAIN_COLOR.get();
                g.setStroke(REF_LINE_STROKE.get());
                g.setColor(mainColor);
                MapViewPath line = new MapViewPath(mv);
                line.moveTo(referenceSegment.getFirstNode());
                line.lineTo(referenceSegment.getSecondNode());
                g.draw(line.computeClippedLine(g.getStroke()));

                g.setStroke(HELPER_LINE_STROKE.get());
                g.setColor(mainColor);
                line = new MapViewPath(mv);
                line.moveTo(helperLineStart);
                line.lineTo(helperLineEnd);
                g.draw(line.computeClippedLine(g.getStroke()));
            }
        }
    }
}
